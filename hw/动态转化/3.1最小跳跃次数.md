为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]>=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。

为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。

示例 1：

输入：jump = [2, 5, 1, 1, 1, 1]

输出：3

解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -> 2 -> 1 -> 6，最终小球弹出了机器。

### 思路

每个位置上的最小到达的次数, 取决于前面所有能到达的最小的次数+1

```python
class Solution:
    def minJump(self, jump: List[int]) -> int:
        # 动态规划 dp[i]表示从i位置跳出所需最小次数
        # 一般想法 ： dp[i] = min(dp[j<i], dp[i+jump[i]]) + 1 复杂度太高 O(n^2)，不容易实现

        # 从后往前遍历 先计算 dp[i]=dp[i+jump[i]]+1 ，后面再更新dp的值。
        # 利用dp[i]‘准单调’性质，dp[i] <= dp[j<i] + 1
        
        n = len(jump)
        dp = [0]*n
        for i in range(n-1,-1,-1):
            dp[i] = 1 if i+jump[i]>=n else dp[i+jump[i]]+1
            # 更新j>i的值，因为j总可以往回跳到i.注意一定要找条件break，否则复杂度O(n^2)
            for j in range(i+1, n): 
                if dp[j]<dp[i]+1: # 后面的j位置所需次数,小于回跳
                    '''这个break部分就特别重点!!!'''
                    break
                dp[j] = dp[i]+1
        return dp[0]
'''逆向遍历,然后对比,然后再判定一个可以会跳的情况'''
```

